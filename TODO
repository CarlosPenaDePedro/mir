MOVE LINES DOWN TO "DONE" AS THINGS ARE IMPLEMENTED ...
PHILOSOPHY:
 1 Make it `work`
 2 Make it `correct`
 3 Make it `fast`


!----- NEXT STEPS (MAKE IS WORK)

    !-- Separate concepts of BBox (mir) and Domain (Atlas) => feature/MIR-84-domain
       --- BBox snaps to points so global can be [0,359] in a --grid=1/1
           it depends on increments
       --- Domain does not (in the Maths sense, e.g. global is [0,360] )

    !- Caching of SH coefficients for SH to LL (faster)
    !- Classic bi-linear
    -- Frames and GG
    --- Shifted Lat/Lon grid (not  passing by 0/0) ///
        Example: tigge,origin=egrr. Need to pass reference point to atlas::LatLon contructor.
        ///
    --- Tackle non-global grids ///
        Look at data from wave model param=swh
        has only latitudes [80N,78S]
    ///
    --- Review LSM selection method/caching and hashing
    - Call HIRLAM routines in emoslib without the need for a rotation (environment variable)
    - Make the logging callback work in emoslib.cc
    - Implement print() method on ATLAS grids
    - Add regression tests to metabuilder
    .- Support of polar stereographic grids (LOW PRIORITY)
    - Consider moving bbox_ to Gridded.h
    - Implement 'global' key for reduced-ll in grib_api (see ReducedLL.cc)

--- METHODS (MAKE IT CORRECT)
    - What is the special treatment for winds (emoslib)
        - Rotated
        - Non-rotated
    - What is the special treatment for precipitations (emoslib)
    - Compare with real prodgen output

--- TESTING (MAKE IT CORRECT)
    - Metabuilder
        --- Clear cache in metabuilder before each run: or select a new directory, better as it will not affect production when mir is operational
        - Test mir_tool with valgrind
        - Make sure we compare mir and emoslib for speed
            - Write MARS timers in JSON
        - Make sure we run diss_requests in metabuilder with date for which the seasonal exists
    - Unit tests
        - Decide on what to test

-- PERFORMANCES (MAKE IT FAST)
    - Memory mapping of the SparseMatrix coefficients: MappedSparseMatrix<double,RowMajor> weights(nrows, ncols, nnz, row_ptr, col_ind, val);
    - Hide Eigen in a light wrapper
    - Implement wrapper with armadilo


- OTHER
    - OPEN QUESTIONS
-        Should we cache identity matrices?
        - Should compute interpolate if matrix is identity?
        - Should we interpolate to the reduced LL?

    - Gather knowledge about emoslib/prodgen/mars
        - EMOSLIB
            - sh to rot latlon - what is the path?
            - how 10m uv grid point - how are they interpolate, intvec?
            - Find out about all intuv* functions
        - MARS
            .- Specifying AREA on a SH field is ignored

CHANGES WE WANT TO MAKE
--- Get rid of AREACHK in mars (like prodgen, does not work for all grids)
--- Prodgen should not do sub-sampling

MEMO:
- Use IFS new interpolation (SH->GG, SH->LL, new code, published paper)
- Wave will go to unstructured grid


LSM:
- High resolution LSM (1km) can be found at https://www.ghrsst.org/products-and-services/tools/navo-ghrsst-pp-land-sea-mask/
- And a 500m one at http://landcover.org/data/watermask/


MIR


- Field using LSM. Talk to me on how to get to the LSM data (e.g. with config, and what class do we need to implement)
- Rotated fields (code is there, needs testing)
- Rotated winds?
- Make sure we don't need to cast constness away
- Make sure cached weight files are not loaded for every field
- Wind interpolation
- Use VOD2UV from trans
- Understand the normalisation of area (-180 - 180 or 0 - 360)
  - Consider dissemniaton request: --reduced=640 --area=a=89.892/300/25.092/60
- remove currently necessary C-style casts when updating to a const-correct version of grib_api
  (currently unstable, casts are for current stable version 1.13.1 which is incorrect)

-
PERFORMANCES
.- Consider switching of some ASSERTions, maybe with a resource
- Cache cropping indices (cropping simply extract value from one vector into another, cache this mapping)
- Find out when it is most effective to compute legendre coefficients on the fly
    ///transi seems to be fast for coarse target resolution, e.g. T1279 => 2x2. In this case it may not be needed to cache the coefficients. We need to study what is the threseold when computing coeff is faster than loading them.///
- Make sure cached mesh files are not loaded for every field (ATLAS)
- Refactor & code cleanup of the Grid hiearchy
- Create a Tesselation interface, with multiple implementations (Delaunay, ReducedGrid, etc)
- Atlas gmsh writer must write with DataHandle
- Speed-up mesh loading
- use gmsh binary format + DataHandle/BufferedHandle

IN TRANS
- Get transi to print an error if memory allocation fails
-
PRODGEN:
- Document what prodgen is doing
- We need to make sure prodgen does not sub-sample
- Is prodgen setting intermediate_gaussian?

MARS:
- Is intermediate_gaussian reduced?



--------------------------------------------------------------------------------------------------
DONE:
+- Vo/D to U/V: Dropping one coefficient
+- Implement general purpose file caching class
+- Cropping of reduced gaussian grid
+- SH=>LL with different increments
+- Check why metdabuilder-test://mir-test/opensuse131/gnu/tests/fixed_tests/egrr_pl fails
+- Merge metabuilder-test back to metabuilder-prod
+- Missing values (e.g. wave field). To get a wave field: retrieve,stream=wave,param=swh,target=wave.grib
+- Check if transi can be called with a regular gaussian as output
+- sharedmem / memmap for caching transi structures
+- SH to LL with different increments north/south and west/east
+- Nearest LSM
+- CacheMesh should take tesselation method into account: done, caching removed
+- Clearing cache in metabuilder ///
        Note: we need to clear the caches of *ALL* cluster nodes
        Posible solution: put the cache in the build directory, so that it is wiped
        at each rebuild
        ///
+- Run metabuilder test on ALL platforms
+- Find bad projections
+b- Implement other LSM, includinf 10 minute and HIRLAMs
+- Rotated regular GG
+- Caching of SH=>LL coefficients


